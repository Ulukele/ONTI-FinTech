Финальная задача профиля ФинТех ОНТИ 2018/19 
====

## Набор заданий

Решение командной задачи разбито на подзадачи, сгруппированные в 3 набора.

Каждая подзадача (_user story_) формулирует необходимый функционал, который должен был быть реализован командой, а также набор приемочных тестов (_acceptance criteria_), позволявших проверить в полном ли объеме решена данная подзадача.

Каждый набор подзадач необходимо решать в отдельном этапе (итерации). Первые два этапа итеративно подводят участников к решению полной финальной задачи, осуществляемому во время последнего третьего этапа. На каждом этапе решение подзадач будет проверяться с помощью системы автоматической проверки решения, которое запускает решение участников с теми или иными параметрами в соответствии с приемочными тестами.

### Первая итерация

  * US-001 Регистрация контракта
  * US-004 Простое добавление пользователя в сервис индентификации
  * US-013 Получение баланса идентифицированного пользователя

### Вторая итерация

  * US-002 Вывод владельца контракта регистра соответствий
  * US-003 Изменение владельца контракта регистра соответствий
  * US-006 Получение всех пользователей из сервиса идентификации
  * US-007 Удаление пользователя из сервиса идентификации
  * US-008 Запуск обучения сервиса индентификации (кроме AC-008-04)
  * US-010 Идентификация пользователя
  * US-014 Отправка запроса на регистрацию соответствия
  * US-015 Отправка запроса на удаление соответствия
  * US-016 Отмена запроса на регистрацию или удаление соответствия
  * US-017 Отправка средств
  * US-021 Получение истории платежей
  * US-023 Получение всех запросов на регистрацию соответствий
  * US-024 Получение всех запросов на удаление соответствий
  * US-025 Подтверждение запросов на регистрацию или удаление соответствий
  * US-026 Получение аккаунта по номеру телефона

### Третья итерация

  * US-005 Улучшенное добавление пользователя в сервис индентификации
  * US-008 Запуск обучения сервиса индентификации (полностью)
  * US-009 Обнаружение уже добавленного пользователя
  * US-011 Запрос действий на безопасную идентификацию пользователя
  * US-012 Безопасная идентификация пользователя
  * US-018 Генерация сертификата на получение средств
  * US-019 Использование сертификата на получение средств
  * US-020 Вернуть средства из неиспользованных сертификатов
  * US-022 Получение истории платежей, включая использование сертификатов

## Условия проведения

В первые день соревнований все члены команд получают ноутбук со следующим набором установленного программного обеспечения:
  * набор Python инструментария Anaconda c установленными библиотеками `web3` (5.0.0a3), `cognitive_face`, `opencv-python`;
  * среды разработки PyCharm и WingIDE;
  * компилятор языка Solidity `solc` (0.5.4);
  * клиент системы ведения версий `git`;
  * Интернет-браузер Chrome.

Каждый ноутбук имеет возможность выхода в сеть Интернет. Команды могут использовать собственные ноутбуки.

Команды могут устанавливать дополнительное программное обеспечение, но после согласование с членами жюри.

Участники во время командного этапа финального тура могут использовать интернет и заранее подготовленные библиотеки для решения задачи.

Участники должны использовать язык программирования Python для написания программ, использующих командную строку. Для написания Ethereum контрактов участники могут использовать любой язык программирования.

Для работы с сервисом _Microsoft Face API_ участникам предоставляется один ключ подписки на команду, а также базовый URL для доступа к REST API. При доступе к сервису с помощью данного ключа действует ограничение на 10 запросов в секунду. Участники одной команды должны сами заботиться о том, чтобы держать ключ в тайне от других команд. Ключ не должен передаваться третьим лицам. Если ресурс ключа подписки (примерно 60000 запросов) полностью используется командой, то организаторы вправе не предоставлять команде другой ключ. 

Участники не могут использовать помощь тренера, сопровождающего лица или привлекать третьих лиц для решения задачи.

Финальная задача формулируется участникам в первый день финального тура, но участники выполняют решение задачи поэтапно. Критерии прохождения каждого этапа формулируются для каждого дня финального тура. За подзадачи, решенные в конкретном этапе начисляются, баллы. Баллы за подзадачи можно получить только в день, закрепленный за конкретным этапом.

В начале первого дня состязаний участники каждой команды получают доступ к репозиторию на серверах GitLab.com. Каждая команда имеет свой собственный репозиторий. Члены других команд не имеют доступ к чужим репозиториям.

В течение дня не ведется учет количества изменений, которые команды регистрируют в Git-репозитории.

В конце каждого дня финального этапа жюри проверяет решение участников на соответствие приемочным тестам для каждой подзадачи, входящей в набор для соответствующей итерации.

Баллы за все подзадачи, для которых прошло приемочное тестирование, определяют баллы, набранные командой в данный день соревнований.

Система автоматического тестирования имеет следующую конфигурацию:
  * OS Linux
  * Python 3.6
  * Python модули (перечислены) и соответствующие зависимости (не перечислены): `web3` (5.0.0a3), `opencv-python`, `cognitive_face`, `dlib`,  `imutils`, `ethereum`
  * `/usr/local/bin/solc` (5.5)
  * `/opt/shape_predictor_68_face_landmarks.dat`

После выставления баллов, командам предоставляется доступ к системе автоматического тестирования, ответственной за проведение приемочных тестов в конкретный день состязаний, так что члены команды могут ознакомиться с логикой проверки и подать апелляцию, если не согласны с корректностью проведения тестов.

После рассмотрения сути апелляции, жюри вправе провести тестирование вручную и назначить команде баллы за соответствующие подзадачи.

В начале следующего дня состязаний жюри выдает всем командам свое решение подзадач предыдущего дня, которое команды могут использовать для того, чтобы решать следующий набор подзадач.

## Процедура проведения приемочного тестирования и критерии оценки

Для каждого дня соревнований (для каждой итерации) справедлива следующая процедура приемочного тестирования:
  * В конце каждого дня финального этапа команды должны сформировать запрос на слияние (Merge Request) из своей ветки исходного кода в основную ветку (`master`) в Git-репозитории.
  * Команда ответственна за то, чтобы в запросе на слияние не должно быть конфликтов. Запрос на слияние с конфликтами может не рассматриваться жюри для выполнения приемочного тестирования.
  * После того, как все команды отправили запросы на слияние, жюри одобряет все запросы и приступает к приемочному тестированию, для тех подзадач, которые входят в соответствующую итерацию. Для этого исходный код приложения команды копируется на сервер жюри, и прогоняются автоматические тесты на соответствие решения участников требованиям к приемочным тестам (acceptance criteria).
  * Если все приемочные тесты для данной подзадачи пройдены успешно, команда получает баллы за данную подзадачу. Если хотя бы один тест не проходит, то баллы за данное подзадачу не начисляются.

Приемочные тесты для каждой подзадачи описаны в разделе "Подробное описание подзадач". 

Дальше перечислены баллы, которые получает команда за решение подзадач в каждой итерации.

Максимальное количество баллов, которое могла набрать команда за решение всех подзадач — 400.

### Первая итерация

| Подзадача | Баллы |
| :---- | :----: |
| US-001 Регистрация контракта | 10 |
| US-004 Простое добавление пользователя в сервис индентификации | 20 |
| US-013 Получение баланса идентифицированного пользователя | 10 |

Максимальное количество баллов за итерацию - 40.

### Вторая итерация

| Подзадача | Баллы |
| :---- | :----: |
| US-002 Вывод владельца контракта регистра соответствий | 10 |
| US-003 Изменение владельца контракта регистра соответствий | 10 |
| US-006 Получение всех пользователей из сервиса идентификации | 10 |
| US-007 Удаление пользователя из сервиса идентификации | 10 |
| US-008 Запуск обучения сервиса индентификации (кроме AC-008-04) | 15 |
| US-010 Идентификация пользователя | 25 |
| US-014 Отправка запроса на регистрацию соответствия | 10 |
| US-015 Отправка запроса на удаление соответствия | 10 |
| US-016 Отмена запроса на регистрацию или удаление соответствия | 15 |
| US-017 Отправка средств | 10 |
| US-021 Получение истории платежей | 20 |
| US-023 Получение всех запросов на регистрацию соответствий | 10 |
| US-024 Получение всех запросов на удаление соответствий | 10 |
| US-025 Подтверждение запросов на регистрацию или удаление соответствий | 15 |
| US-026 Получение аккаунта по номеру телефона | 10 |

Максимальное количество баллов за итерацию - 190.

### Третья итерация

| Подзадача | Баллы |
| :---- | :----: |
| US-005 Улучшенное добавление пользователя в сервис индентификации | 50 |
| US-008 Запуск обучения сервиса индентификации (полностью) | 5 |
| US-009 Обнаружение уже добавленного пользователя | 20 |
| US-011 Запрос действий на безопасную идентификацию пользователя | 5 |
| US-012 Безопасная идентификация пользователя | 35 |
| US-018 Генерация сертификата на получение средств | 10 |
| US-019 Использование сертификата на получение средств | 15 |
| US-020 Вернуть средства из неиспользованных сертификатов | 20 |
| US-022 Получение истории платежей, включая использование сертификатов | 10 |

Максимальное количество баллов за итерацию - 170.

## Подробное описание подзадач

Решение представляет из себя набор python скриптов (компонент), каждый из который ответственен за определенный функционал. 

Управление скриптами происходит через параметры командной строки и через конфигурационные файлы. Параметры командной строки описываются отдельно в разделах, где описывается функциональность каждого скрипта. Конфигурационные файлы - файлы в формате JSON, должны читаться из текущей директории, где происходит вызов скрипта и могут быть двух типов
  * конфигурационный файл с настройками для работы с _Microsoft Face API_
  * конфигурационный файл с настройками для работы с Ethereum узлом

**Конфигурационный файл с настройками для MS Face API**

Имя: `faceapi.json`

Содержит следующую информацию:
  * `key` - ключ подписки для использования сервиса;
  * `serviceUrl` - URL для доступа к сервису;
  * `groupId` - группа пользователей (в терминах _MS Face API_), с которой работает в данный момент скрипт.

Пример файла:
```json
{"key": "563879b61984550e40cbbe8d3039523c",
 "serviceUrl": "https://westeurope.api.cognitive.microsoft.com/face/v1.0/",
 "groupId": "fintech-01"}
```

**Конфигурационный файл с настройками для узла Ethereum**

Имя: `network.json`

Содержит следующую информация:
  * `rpcUrl` - URL для доступа к узлу по JSON RPC;
  * `privKey` - приватный ключ аккаунта для подписи транзакций, отправляемых на узел Ethereum, и для локальных вызовов;
  * `gasPriceUrl` - URL для доступа к сервису, предоставляющему цену за газ. Данный сервис возвращает JSON, из которого нужно взять значение (в _gwei_) из поля `fast`:
     ```json
     {"block_time":19.91,"fast":10.0,"instant":25.0,"block_number":7240426,"standard":5.0,"health":true,"slow":3.0}
     ```
  * `defaultGasPrice` - цена за газ в wei, использующаяся, если нельзя получить цену за газ из сервиса .

Пример файла:
```json
{"rpcUrl": "https://sokol.poa.network", 
 "privKey": "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", 
 "gasPriceUrl": "https://gasprice.poa.network/", 
 "defaultGasPrice": 2000000000}
```

Если это явно не прописано в описании функционала соответствующей компоненты, она не должна оставлять после себя никаких файлов-данных. Аналогично с получением данных - чтение данных из файла должно происходить только в нескольких случаях
  - для получения настроек для работы с MS Face API,
  - для получения видеопотока, эмулирующего камеру.
  - для получения настроек для работы с Ethereum узлом,
  - для получения Application Binary Interface контракта или его байткода, 
  - или если это явно указано в описании компоненты,
в остальных случаях данные должны быть получены из сервиса MS Face API или блокчейн сети. 

Все компоненты, работающие с сервисом _MS Face API_, должны уметь обрабатывать ситуации, когда:
  - недоступно подключение к сервису (сообщение об ошибке "No connection to MS Face API provider");
  - используется некорректный ключ подписки (сообщение об ошибке "Incorrect subscription key").

Компоненты, отправляющие транзакции в блокчейн, должны уметь обрабатывать ситуации, когда:
  - недоступно подключение к узлу Ethereum (сообщение об ошибке "No connection to node");
  - на счету аккаунта, от чьего имени выполняется транзакция, недостаточно средств, чтобы покрыть все затраты по использованному газу (сообщение об ошибке "No enough funds to send transaction");
  - транзакция может не включаться в блок продолжительное время в зависимости от нагрузки на сеть (сообщение об ошибке "Transaction is not validated too long").

При возникновении данных событий в терминал должно выдаваться сообщение понятное пользователю, а не stack trace.

Возможны также другие конфигурационные файлы, необходимые для работы тех или иных подсистем решения. Данные файлы будут отдельно описываться в соответствующих разделах. 

## Описание компонент

### Настройка сервиса KYC

Развертывание и настройка в блокечейн сети регистра соответствий аккаунтов и телефонных номеров (Know Your Customer, KYC) выполняется компанией производителем программного обеспечения (тем, кто разрабатывает данный сервис). Тоже самое относится к обработчику сертификатов на получение средств. Предполагается, что в потенциальные пользователи сервиса (пользователи, регистрирующие соответствия, владельцы платежных терминалов) могут ознакомиться с опубликованным в открытом доступе исходным кодом контрактов, принять решение на основе этого, доверять ли этому разработчику и начать пользоваться сервисом.

Фиксация контрактов в блокчейн гарантирует, что приозводитель не сможет изменить логику работы приложения позднее, т.е. условия участия в системе, с которыми ознакомились пользователи, не поменяется.

Функционал сервиса KYC должен быть доступен сразу, минуя фазы настройки, когда контракт зарегистрирован в блокчейн, но еще находится в нерабочем состоянии. Поэтому первичная настройка базовых параметров по максимуму должна выполняться вовремя инициализации контракта во время его регистрации (deploy).

**Синтаксис**
```shell
setup.py <command> [options]
```

#### US-001 Регистрация контракта

##### Использование скрипта
```shell
$ setup.py --deploy
```

Подключается к узлу Ethereum и регистрирует следующие контракты
* регистр соответствий аккаунтов и телефонных номеров в сети блокчейн. 
* обработчик сертификатов на получение средств.

На терминал выводятся адреса зарегистрованных контрактов. В текущей рабочей директории создается JSON файл `registrar.json`, содержащий адреса зарегистрированных контрактов.

##### Критерий оценивания AC-001-01
```shell
$ cat registrar.json
cat: registrar.json: No such file or directory
$ setup.py --deploy
KYC Registrar: 0x00360d2b7D240Ec0643B6D819ba81A09e40E5bCd
Payment Handler: 0x95426f2bC716022fCF1dEf006dbC4bB81f5B5164
$ cat registrar.json
{"registrar": {"address": "0x00360d2b7D240Ec0643B6D819ba81A09e40E5bCd", "startBlock": 123456}, "payment": {"address": "0x95426f2bC716022fCF1dEhttps://gasprice.poa.network/f006dbC4bB81f5B5164", "startBlock": 123457}}
```
_Комментарий_:

В блокчейн сеть отправляются транзакции для регистрации и первичной настройке контрактов. Транзакции успешно включены в один
или несколько блоков. Для проведения транзакции выбрана цена из значения `fast`, возвращенного сервисом `https://gasprice.poa.network`. Контракты по адресу, выведенным в терминале, созданы одной из отправленных транзакций, и могут быть просмотрены с помощью браузера блоков. 

##### Критерий оценивания AC-001-02
```shell
$ cat registrar.json
{"registrar": {"address": "0x00360d2b7D240Ec0643B6D819ba81A09e40E5bCd", "startBlock": 123456}, "payment": {"address": "0x95426f2bC716022fCF1dEf006dbC4bB81f5B5164", "startBlock": 123457}}
$ setup.py --deploy
KYC Registrar: 0x23B40E5bCd06D819ba81A09e0340Ec06460d2b7D
Payment Handler: 0xE797A1da01eb0F951E0E400f9343De9d17A06bac
$ cat registrar.json
{"registrar": {"address": "0x23B40E5bCd06D819ba81A09e0340Ec06460d2b7D", "startBlock": 456123}, "payment": {"address": "0xE797A1da01eb0F951E0E400f9343De9d17A06bac", "startBlock": 456125}}
```
_Комментарий_: 

Контракты по адресам, выведенным в терминале, созданы одной из отправленных транзакций, и могут быть просмотрены с помощью браузера блоков. 

##### Критерий оценивания AC-001-03
```shell
$ cat network.json | python -mjson.tool | grep gasPriceUrl 
    "gasPriceUrl": "https://gasprice.poa.network/",
$ curl https://gasprice.poa.network/
curl: (6) Could not resolve host: gasprice.poa.network
$ setup.py --deploy
KYC Registrar: 0x9FdddF5bf10c65221da0a78ADAFec1D8E9EF0A7D
Payment Handler: 0xD79A8FDB771Ea12359270aD7020bcCB328C9f5f7
```
_Комментарий_:

В блокчейн сеть отправляются транзакции для регистрации и первичной настройке контрактов. Транзакции успешно включены в один
или несколько блоков. Для проведения транзакции выбрана цена из значения `defaultGasPrice` из файла `network.json`.

#### US-002 Вывод владельца контракта регистра соответствий

##### Использование скрипта
```shell
$ setup.py --owner registrar
```

Подключается к узлу Ethereum и получает адрес аккаунта, имеющего полномочия выполнять действия по подверждению запросов на регистрацию и удалению соответствий аккаунтов и телефонных номеров в сети блокчейн. 

На терминал выводится адрес аккаунта.

#### US-003 Изменение владельца контракта регистра соответствий

##### Использование скрипта
```shell
$ setup.py --chown registrar <address>
```

Подключается к узлу Ethereum и отправляет транзакцию на изменение аккаунта, имеющего полномочия выполнять действия по подверждению запросов на регистрацию и удалению соответствий аккаунтов и телефонных номеров в сети блокчейн. Только аккаунт, в текущее время обладающий полномочиями на выполнение вышеуказанных действий, имеет возможность производить данное изменение.

На терминал выводится адрес нового аккаунта.

### Подотовка сервиса идентификации

Сервис идентификации человека по лицу перед полноценной работой требует предварительной настройки. Первое, что должно быть сделано - в сервис необходимо добавить лица людей, которых в дальнейшем необходимо идентифицировать. Поскольку система автоматического тестирования не может работать с камерой, то изображения человека будут передаваться через видео-файл, передаваемый в сервис через параметры командной строки.  

Администратор свервиса должен иметь возможность просматривать список добавленных пользователей, удалять пользователя (и его изображения) из системы. 

Как только необходимое количество лиц зарегистрировано в сервисе, администратор может запустить обучение нейронной сети.

**Синтаксис**
```shell
face-management.py <command> [options]
```

#### US-004 Простое добавление пользователя в сервис индентификации

Сервис должен быть устроен так, что добавление изображений человека в систему происходит анонимно, т.е. имя при добавлении не указывается. 

##### Использование скрипта
```shell
$ face-management.py --simple-add <path to video file>
```

При использовании команды простого добавления пользователя из видео-потока извлекается 5 кадров с изображением лица человека. При этом подразумевается, что все кадры в видео приндалежат одному и тому же человеку. 

Если в видео-потоке недостаточно кадров с изображением человека, то обработка такого видео должно приводить к ошибке. 

##### Критерий оценивания AC-004-01
```shell
$ cat faceapi.json | python -mjson.tool | grep groupId
    "groupId": "fintech-01",
$ curl -X GET "https://westeurope.api.cognitive.microsoft.com/face/v1.0/persongroups/fintech-01" -H "Content-Type: application/json" -H "Ocp-Apim-Subscription-Key: 000000000000000000000000000000000" 
{"error":{"code":"PersonGroupNotFound","message":"Person group is not found.\r\nParameter name: personGroupId"}}
$ face-management.py --simple-add /path/to/video.avi
5 frames extracted
PersonId: 419e345a-e6d6-4d9c-953d-667787b8d52e
FaceIds
=======
e27558b9-812d-41c3-b114-8e434b8f4602
44c350f2-6653-4616-a1b7-e0fe9b481b6b
f945a3be-4b20-4049-b080-4142a55e4f93
855ab7c2-9bb3-49ed-8cac-1366c0274b08
9c4af288-54cd-4375-8eef-f8c29ed56685
```
_Комментарий_:

Требуемый `personGroupId` не существовал до этого в сервисе _Microsoft Face API_. После добавления `personGroupId` добавляется новый `personId`, с которым ассоциируется 5 изображений лица (`persistedFaceId`). 

##### Критерий оценивания AC-004-02
```shell
$ cat faceapi.json | python -mjson.tool | grep groupId
    "groupId": "fintech-01",
$ curl -X GET "https://westeurope.api.cognitive.microsoft.com/face/v1.0/persongroups" -H "Content-Type: application/json" -H "OcApim-Subscription-Key: 000000000000000000000000000000000" 
[{"personGroupId":"fintech-01","name":"fintech-01","userData":null}]
$ face-management.py --simple-add /path/to/video1.avi
5 frames extracted
PersonId: 37da04e7-f471-49c7-a54c-a08f05950fc5
FaceIds
=======
1d499868-3d01-487c-8bab-626dc562e4e8
27dadf08-bc60-4a29-82a7-7d21ea7f40af
b8cf9c2f-a606-4f21-851d-26e0a0dc8a74
bf4806de-8c4b-4a12-8495-002f43dba797
ff79486f-15ac-43be-9c6c-b2840f8c8d22
```
_Комментарий_:

Требуемый `personGroupId` существует в _Microsoft Face API_. В данную группу добавляется новый `personId`, с которым ассоциируется 5 изображений лица (`persistedFaceId`). 

##### Критерий оценивания AC-004-03
```shell
face-management.py --simple-add /path/to/video2.avi
Video does not contain any face
```
_Комментарий_:

Выдается ошибка при попытке обработать видео, в котором либо нет кадров с лицом пользователя, либо в видео содержится меньше 5 кадров. Группа с `personGroupId` не создается, новый `personId` не добавляется.

##### Критерий оценивания AC-004-04
```shell
$ face-management.py --simple-add /path/to/video1.avi
5 frames extracted
PersonId: 52865cde-3af8-443d-b260-9319c2cb1788
FaceIds
=======
cdb6227e-7453-4057-b4fa-79660914e597
6976d3c2-dee5-4f24-8950-f38ff10c70ad
fae15e55-6639-42a4-a954-731c33310e41
15092567-5765-49ed-ac63-94bc5fa08d17
a77f1f0a-aa95-4bd1-9826-6b453aec42b2
$ face-management.py --simple-add /path/to/video31.avi
5 frames extracted
PersonId: 9fa0a99b-8e76-474d-8223-dea217c2c19b
FaceIds
=======
b552ef11-a162-4a7d-9047-ccfc84a07043
90c0815a-ecce-45c6-8107-ced7ef29a249
fde35dba-505d-4a62-ac5a-c6ae4c89128e
6c6910b4-0ab5-4eb4-9e53-95b1929f9867
fdb9d352-65b0-41a2-a1be-03ea5b543160
$ face-management.py --simple-add /path/to/video41.avi
5 frames extracted
PersonId: f290ecb9-bfab-46f7-b623-45140d730628
FaceIds
=======
e5735ecd-ca09-4fd4-bfd3-8ace67702ab0
9e1bbdee-5981-4f6b-aba5-03be57e5e910
3120ef58-8d53-4558-8b84-784ba338f621
8fceb9c7-f029-4326-9703-6749005674fa
8ea02a3b-7dc0-455a-858c-67251b0ca3b4
```
_Комментарий_:

Несколько добавлений пользователя проходят успешно. Для каждого видео добавляется новый `personId` добавляется.


#### US-005 Улучшенное добавление пользователя в сервис индентификации

Наличие в наборе изображений одного и того же человека, но у которых есть различия в мимике, положении головы и освещенности, влияет на качество обучения нейронной сети сервиса, поэтому при сборе данных для сервиса идентификации важно собирать разные изображения.

##### Использование скрипта
```shell
$ face-management.py --add <path to video file 1> [ <path to video file 2> [ <path to video file 3> [ <path to video file 4> [ <path to video file 5> ] ] ] ]
```

Команда ожидает 5 видео файлов. Требования к каждому из видео файлов:
  * В первом по списку видеофайле лицо человека должно быть неподвижно (допускаются небольшие повороты)
  * Во втором по списку видеофайле должны быть зафиксированы наклоны головы влево и вправо (_roll_)
  * В третьем по списку видеофайле должны быть зафиксированы повороты головы влево и вправо (_yaw_)
  * В четвертом видеофайле должен быть зафиксирован открытый рот
  * В пятом - должно быть зафиксировано закрытие глаз

#### US-006 Получение всех пользователей из сервиса идентификации

Администратор сервиса может получить список всех добавленных пользователей. 

##### Использование скрипта
```shell
$ face-management.py --list
```

#### US-007 Удаление пользователя из сервиса идентификации

Администратор сервиса может удалить пользователя сервиса по его идентификатору. 

##### Использование скрипта
```shell
$ face-management.py --del <person id>
```

#### US-008 Запуск обучения сервиса индентификации 

Администратор сервиса может запустить обучение нейронной сети сервиса _Microsoft Face API_ для возможности дальнейшего распознавания человека по лицу.

Обучение должно запускаться только если до этого происходило добавление или удаление нового человека.

##### Использование скрипта
```shell
$ face-management.py --train
```

#### US-009 Обнаружение уже добавленного пользователя 

Администратор сервиса не сможет добавить пользователя в сервис _Microsoft Face API_, если изображения лица данного пользователя уже были добавлены в систему, и эти изображения были использованы для обучения сервиса.

### Взаимодействие с пользователем

#### US-010 Идентификация пользователя

Для идентификации пользователя, компонента использует кадры с лицом из видео-потока и отправляет их в сервис _Microsoft Face API_. 

##### Использование скрипта
```shell
$ faceid.py --find <path to video file>
```

В случае, когда в текущей директории нет файла `actions.json`, то запускается простой (небезопасный) способ аутентификации. При этом из видео-потока извлекается 5 кадров с изображением лица человека. Подразумевается, что все кадры в видео приндалежат одному и тому же человеку. Идентификация человека происходит успешно, если кадры из видео указывают на одного и того же человека с высокой степенью (не менее 50%) уверенности определения.

Если в видео-потоке недостаточно кадров с изображением человека или на изображении невозможно определить лицо, то обработка такого видео должно приводить к ошибке. 

После успешной идентификации в текущей директории создается (если файл уже существовал, то он пересоздается) файл `person.json`, в котором указывается идентификатор, возвращенный сервисом _Microsoft Face API_. Пример файла:
```json
{"id": "37da04e7-f471-49c7-a54c-a08f05950fc5"}
```

#### US-011 Запроса действий на безопасную идентификацию пользователя

в JSON помещается набор действий, которые должен выполнить пользователь

##### Использование скрипта
```shell
$ faceid.py --actions
```

#### US-012 Безопасная идентификация пользователя

Должен быть action JSON, сохраняет PersonId в person JSON.

##### Использование скрипта
```shell
$ faceid.py --find /path/to/video.avi
```

#### US-013 Получение баланса идентифицированного пользователя

После идентификации пользователь может получить баланс на соответствующем данному пользователю аккаунте в сети блокчейн.

##### Использование скрипта
```shell
$ faceid.py --balance <PIN code>
```

Используя идентификатор, содержащийся в `person.json`, и PIN-код скрипт генерирует приватный ключ пользователя. В блокчейн сеть отправляется запрос на баланс аккаунта, полученного из приватного ключа.

Приватный ключ генерируется по правилу:

$$K = keccak256(keccak256(keccak256(keccak256(keccak256(''), I, P_1), I, P_2), I, P_3), I, P_4)$$

где $''$ - 'пустая' последовательность байт, $I$ - это идентификатор, который возвращает система распознавания по лицу, приведенный к длине в 16 байт, а ($P_1$, $P_2$, $P_3$, $P_4$) - четыре цифры PIN-кода, где каждая цифра представлена целым числом длиной 1 байт, $P_1$ - цифра самого старшего разряда в PIN-коде (первая цифра), а $P_4$ - цифра самого младшего разряда в PIN-коде (последняя цифра).

Например, идентификатору `37da04e7-f471-49c7-a54c-a08f05950fc5` при применении PIN-кода `1234` соответствует приватный ключ `6be7217f318a6409ba8e87e42ce600e14153647a816f7f2d43d244d1a00ed3df`.

При выводе баланса должно быть автомтическое масштабирование суммы - нормализация к одному из возможных значений: _poa_, _finney_, _szabo_, _gwei_, _mwei_, _kwei_, _wei_. Происходит следующим образом:
  * Используется минимально возможное нормализованное значение, чья целая часть больше ноля;
  * Дробная часть записывается с округлением до $10^{-6}$;
  * Завершающие нули в дробной части, полученные полсе округления, не записываются (например, 1.3, но не 1.300000).

##### Критерий оценивания AC-013-01
```shell
$ cat person.json
{"id": "37da04e7-f471-49c7-a54c-a08f05950fc5"}
$ faceid.py --balance 4590
Your balance is 2.5 poa
```
_Комментарий_:

Баланс пользователя получен от узла блокчейн сети, доступ к которому получен через JSON RPC.

##### Критерий оценивания AC-013-02
```shell
$ cat person.json
{"id": "a9d0f1d5-1359-43ca-bcc3-cc7c1e314b86"}
$ faceid.py --balance 1864
Your balance is 84.000138 szabo poa
```
_Комментарий_:

Баланс пользователя получен от узла блокчейн сети, доступ к которому получен через JSON RPC.

##### Критерий оценивания AC-013-03
```shell
$ cat person.json
{"id": "37da04e7-f471-49c7-a54c-a08f05950fc5"}
$ faceid.py --balance 6879
Your balance is 0 poa
```
_Комментарий_:

Неправильно задан PIN-код, поэтому баланс запрашивается у несуществующего аккаунта.

##### Критерий оценивания AC-013-04
```shell
$ cat person.json
cat: person.json: No such file or directory
$ faceid.py --balance 6879
ID is not found
```
_Комментарий_:

Выдается ошибка, если в текущей директории не существует файл `person.json`.

#### US-014 Отправка запроса на регистрацию соответствия

После идентификации пользователь может отправить запрос на регистрацию соответствия между телефоном и своим аккаунтом.

##### Использование скрипта
```shell
$ faceid.py --add <pin code> <phone number>
```

Используя идентификатор, содержащийся в `person.json`, и PIN-код скрипт генерирует приватный ключ пользователя. В блокчейн сеть отправляется транзакция к контракту регистра соответствий с запросом регистрации. В терминал выводится хэш транзакции, в рамках которой в контракт добавлен запрос регистрации.  

#### US-015 Отправка запроса на удаление соответствия

После идентификации пользователь может отправить запрос на удаление соответствия между телефоном и своим аккаунтом.

##### Использование скрипта
```shell
$ faceid.py --del <pin code>
```

Используя идентификатор, содержащийся в `person.json`, и PIN-код скрипт генерирует приватный ключ пользователя. В блокчейн сеть отправляется транзакция к контракту регистра соответствий с запросом удаления. В терминал выводится хэш транзакции, в рамках которой в контракт добавлен запрос удаления.  

#### US-016 Отмена запроса на регистрацию или удаление соответствия

После идентификации пользователь может отправить отмену для запроса на добавление или удаление соответствия между телефоном и своим аккаунтом.

##### Использование скрипта
```shell
$ faceid.py --cancel <pin code>
```

Используя идентификатор, содержащийся в `person.json`, и PIN-код скрипт генерирует приватный ключ пользователя. В блокчейн сеть отправляется транзакция к контракту регистра соответствий на отмену запроса добавления или удаления соответствия. В терминал выводится хэш транзакции, в рамках которой просиходит отмена.  

#### US-017 Отправка средств 

##### Использование скрипта
```shell
$ faceid.py --send <pin code> <phone number> <value> 
```

#### US-018 Генерация сертификата на получение средств

После идентификации пользователь может отправить запрос на создание сертификата на получение определенного количества средств. Созданный сертификат впоследствии может быть использован любым пользователем до истечения срока действия. 

##### Использование скрипта
```shell
$ faceid.py --gift <pin code> <value> <expire date>
```
Используя идентификатор, содержащийся в `person.json`, и PIN-код скрипт генерирует приватный ключ пользователя. В блокчейн сеть отправляется транзакция к контракту управления сертификатами на создание нового сертификата на указанную сумму в `wei`, действующий до указанной даты в формате `HH:MM DD.MM.YYYY`. В терминал выводится созданный цифровой сертификат.

#### US-019 Использование сертификата на получение средств 

##### Использование скрипта
```shell
$ faceid.py --receive <pin code> <hex code of certificate>
```

#### US-020 Вернуть средства из неиспользованных сертификатов 

##### Использование скрипта
```shell
$ faceid.py --withdraw <pin code>
```

#### US-021 Получение истории платежей 

##### Использование скрипта
```shell
$ faceid.py --ops <pin code>
```

#### US-022 Получение истории платежей, включая использование сертификатов

##### Использование скрипта
```shell
$ faceid.py --opsall <pin code>
```

### Администрирование сервиса KYC

Управление сервисом соответствий блокчейн аккаунтов и номеров телефонов происходить с использованием отдельной компоненты. Эта компонента позволяет администратору сервиса подтерждать запросы на регистрацию соответствий и запросы на удаление соответствий. 

**Синтаксис**
```shell
kyc.py <command> [options]
```

В зависимости от команды, через RPC узел блокчейн сети будет отправляться либо запрос на информацию, либо транзакция к контракту регистра соответствий. 

#### US-023 Получение всех запросов на регистрацию соответствий

Любой пользователь сервиса,  может получить список всех запросов на регистрацию соответствий. 

##### Использование скрипта
```shell
$ kyc.py --list add
```

Через RPC узел блокчейн сети отправляется запрос к контракту, адрес которого указан в поле `registrar` файла `registrar.json`, на получение всех неотменненных запросов на регистрацию соответствий. Запросы выводятся в формате `отправитель запроса: номер телефона`

#### US-024 Получение всех запросов на удаление соответствий

Любой пользователь сервиса,  может получить список всех запросов на удаление соответствий. 

##### Использование скрипта
```shell
$ kyc.py --list del
```

Через RPC узел блокчейн сети отправляется запрос к контракту, адрес которого указан в поле `registrar` файла `registrar.json`, на получение всех неотменненных запросов на удаление соответствий. Запросы выводятся в формате `отправитель запроса: номер телефона`

#### US-025 Подтверждение запросов на регистрацию или удаление соответствий

Только администратор KYC сервиса имеет полномочия подтверждать запросы на регистрацию или удаление соответствий аккаунтов пользователей их телефонным номерам. 

##### Использование скрипта
```shell
$ kyc.py --confirm <address>
```

В блокчейн сеть отправляется транзакция к контракту регистра соответствий. Контракт проверяет обладает ли отправитель транзакции полномочиями по подтверждению запросов, после чего происходит изменение статуса запроса:
  * если запрос был на регистрацию соответствия между аккаунтом и телефонным номером, то это соответствие становится доступным для других пользователей;
  * если запрос был на удаление соответствия, то соответствие перестает существовать - по номеру телефона, который указывался в соответствии, больше нельзя будет получить адрес аккаунта.

#### US-026 Получение аккаунта по номеру телефона

##### Использование скрипта
```shell
$ kyc.py --get <phone number>
```
